use super::vad::{VadConfig, VoiceActivityDetector};
use super::{AudioConfig, AudioSource};
use anyhow::{bail, Context, Result};
use crate::ffi::sherpa_onnx_bindings::*;
use serde::{Deserialize, Serialize};
use std::ffi::CString;
use std::path::Path;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use tauri::{AppHandle, Emitter};
use tokio::task::JoinHandle;

/// KWS configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KwsConfig {
    pub keyword: String,
    pub score_threshold: f32,
    pub refractory_ms: u64,
    pub endpoint_ms: u64,
    pub provider: String,
    pub max_active_paths: usize,
    pub enabled: bool,
}

impl Default for KwsConfig {
    fn default() -> Self {
        Self {
            keyword: "hey ember".to_string(),
            score_threshold: 0.60,
            refractory_ms: 1200,
            endpoint_ms: 300,
            provider: "cpu".to_string(),
            max_active_paths: 4,
            enabled: true,
        }
    }
}

/// Sensitivity presets
#[derive(Debug, Clone)]
pub enum Sensitivity {
    Low,
    Balanced,
    High,
}

impl Sensitivity {
    pub fn threshold(&self) -> f32 {
        match self {
            Sensitivity::Low => 0.70,
            Sensitivity::Balanced => 0.60,
            Sensitivity::High => 0.50,
        }
    }

    pub fn endpoint_ms(&self) -> u64 {
        match self {
            Sensitivity::Low => 350,
            Sensitivity::Balanced => 300,
            Sensitivity::High => 250,
        }
    }

    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "low" => Some(Sensitivity::Low),
            "balanced" => Some(Sensitivity::Balanced),
            "high" => Some(Sensitivity::High),
            _ => None,
        }
    }
}

/// Wake-word detection event
#[derive(Debug, Clone, Serialize)]
pub struct WakeWordEvent {
    pub keyword: String,
    pub score: f32,
}

/// Keyword spotter using Sherpa-ONNX Zipformer
///
/// Integrates with Sherpa-ONNX C API for real-time streaming keyword spotting.
/// Uses the Zipformer GigaSpeech model for accurate "Hey Ember" detection.
pub struct KeywordSpotter {
    config: Arc<Mutex<KwsConfig>>,
    vad: VoiceActivityDetector,
    last_detection: Option<Instant>,
    kws_handle: *mut SherpaOnnxKeywordSpotter,
    stream: *mut SherpaOnnxOnlineStream,
    sample_rate: u32,
    // Keep CStrings alive for the lifetime of the spotter
    _encoder_path: CString,
    _decoder_path: CString,
    _joiner_path: CString,
    _tokens_path: CString,
    _keywords: CString,
    _provider: CString,
}

impl KeywordSpotter {
    /// Load KWS models and initialize detector
    pub fn new(
        model_dir: &Path,
        config: KwsConfig,
        vad_config: VadConfig,
        sample_rate: u32,
    ) -> Result<Self> {
        log::info!("Initializing KWS from: {}", model_dir.display());

        // Verify model files exist
        let encoder_path = model_dir.join("encoder.onnx");
        let decoder_path = model_dir.join("decoder.onnx");
        let joiner_path = model_dir.join("joiner.onnx");
        let tokens_path = model_dir.join("tokens.txt");

        if !encoder_path.exists()
            || !decoder_path.exists()
            || !joiner_path.exists()
            || !tokens_path.exists()
        {
            bail!(
                "Missing KWS model files in {}. Expected: encoder.onnx, decoder.onnx, joiner.onnx, tokens.txt",
                model_dir.display()
            );
        }

        log::info!("  Encoder: {}", encoder_path.display());
        log::info!("  Decoder: {}", decoder_path.display());
        log::info!("  Joiner:  {}", joiner_path.display());
        log::info!("  Tokens:  {}", tokens_path.display());

        // Convert paths to CStrings (keep them alive)
        let encoder_cstr = CString::new(encoder_path.to_str().unwrap())
            .context("Failed to convert encoder path to CString")?;
        let decoder_cstr = CString::new(decoder_path.to_str().unwrap())
            .context("Failed to convert decoder path to CString")?;
        let joiner_cstr = CString::new(joiner_path.to_str().unwrap())
            .context("Failed to convert joiner path to CString")?;
        let tokens_cstr = CString::new(tokens_path.to_str().unwrap())
            .context("Failed to convert tokens path to CString")?;
        let keywords_cstr =
            CString::new(config.keyword.clone()).context("Failed to convert keyword to CString")?;
        let provider_cstr = CString::new(config.provider.clone())
            .context("Failed to convert provider to CString")?;

        // Initialize Sherpa-ONNX KWS
        let kws_config = SherpaOnnxKeywordSpotterConfig {
            feat_config: SherpaOnnxFeatureConfig {
                sample_rate: sample_rate as i32,
                feature_dim: 80,
            },
            model_config: SherpaOnnxOnlineModelConfig {
                transducer: SherpaOnnxOnlineTransducerModelConfig {
                    encoder: encoder_cstr.as_ptr(),
                    decoder: decoder_cstr.as_ptr(),
                    joiner: joiner_cstr.as_ptr(),
                },
                tokens: tokens_cstr.as_ptr(),
                num_threads: 2,
                provider: provider_cstr.as_ptr(),
                debug: 0,
                model_type: std::ptr::null(),
                modeling_unit: std::ptr::null(),
                bpe_vocab: std::ptr::null(),
                paraformer: SherpaOnnxOnlineParaformerModelConfig::default(),
                zipformer2_ctc: SherpaOnnxOnlineZipformer2CtcModelConfig::default(),
            },
            max_active_paths: config.max_active_paths as i32,
            num_trailing_blanks: 1,
            keywords_score: config.score_threshold,
            keywords_threshold: config.score_threshold,
            keywords_file: std::ptr::null(),
        };

        log::info!("Creating Sherpa-ONNX keyword spotter...");
        let kws_handle = unsafe { SherpaOnnxCreateKeywordSpotter(&kws_config) };

        if kws_handle.is_null() {
            bail!("Failed to create Sherpa-ONNX keyword spotter. Check model files and paths.");
        }

        // Add keywords to the spotter
        log::info!("Adding keyword: '{}'", config.keyword);
        unsafe {
            SherpaOnnxKeywordSpotterAddKeyword(kws_handle, keywords_cstr.as_ptr());
        }

        // Create stream for processing
        log::info!("Creating keyword spotter stream...");
        let stream = unsafe { SherpaOnnxCreateKeywordStream(kws_handle) };

        if stream.is_null() {
            unsafe {
                SherpaOnnxDestroyKeywordSpotter(kws_handle);
            }
            bail!("Failed to create keyword spotter stream");
        }

        // Initialize VAD
        let vad = VoiceActivityDetector::new(vad_config, sample_rate)?;

        log::info!(
            "KWS initialized: keyword='{}', threshold={:.2}, sample_rate={}Hz",
            config.keyword,
            config.score_threshold,
            sample_rate
        );

        Ok(Self {
            config: Arc::new(Mutex::new(config)),
            vad,
            last_detection: None,
            kws_handle,
            stream,
            sample_rate,
            _encoder_path: encoder_cstr,
            _decoder_path: decoder_cstr,
            _joiner_path: joiner_cstr,
            _tokens_path: tokens_cstr,
            _keywords: keywords_cstr,
            _provider: provider_cstr,
        })
    }


    /// Process an audio frame and detect keyword
    ///
    /// Returns Some(score) if keyword detected, None otherwise
    pub fn process_frame(&mut self, samples: &[i16]) -> Option<f32> {
        // VAD gating
        if !self.vad.process_frame(samples) {
            return None;
        }

        // Check refractory period
        let config = self.config.lock().unwrap();
        if let Some(last) = self.last_detection {
            let elapsed = last.elapsed();
            if elapsed < Duration::from_millis(config.refractory_ms) {
                return None; // Still in refractory period
            }
        }

        // Convert i16 samples to f32 normalized to [-1, 1]
        let samples_f32: Vec<f32> = samples
            .iter()
            .map(|&s| s as f32 / i16::MAX as f32)
            .collect();

        // Feed audio to Sherpa-ONNX stream
        unsafe {
            SherpaOnnxOnlineStreamAcceptWaveform(
                self.stream,
                self.sample_rate as i32,
                samples_f32.as_ptr(),
                samples_f32.len() as i32,
            );
        }

        // Check if stream is ready for decoding
        let is_ready = unsafe { SherpaOnnxIsKeywordStreamReady(self.kws_handle, self.stream) };

        if is_ready != 0 {
            // Decode the stream
            unsafe {
                SherpaOnnxDecodeKeywordStream(self.kws_handle, self.stream);
            }

            // Get the result
            let result = unsafe { SherpaOnnxGetKeywordResult(self.kws_handle, self.stream) };

            if !result.is_null() {
                let result_ref = unsafe { &*result };
                let keyword_cstr = unsafe { std::ffi::CStr::from_ptr(result_ref.keyword) };
                let keyword_str = keyword_cstr.to_string_lossy();

                // Check if a keyword was detected (non-empty keyword string)
                if !keyword_str.is_empty() {
                    let score = result_ref.score;

                    // Destroy the result to free memory
                    unsafe {
                        SherpaOnnxDestroyKeywordResult(result);
                    }

                    if score >= config.score_threshold {
                        log::debug!(
                            "Keyword detected: '{}' with score {:.3}",
                            keyword_str,
                            score
                        );
                        drop(config); // Release lock before updating
                        self.last_detection = Some(Instant::now());
                        return Some(score);
                    }
                } else {
                    // Destroy the result even if no keyword detected
                    unsafe {
                        SherpaOnnxDestroyKeywordResult(result);
                    }
                }
            }
        }

        None
    }


    /// Update sensitivity setting
    pub fn set_sensitivity(&mut self, sensitivity: Sensitivity) {
        let mut config = self.config.lock().unwrap();
        config.score_threshold = sensitivity.threshold();
        config.endpoint_ms = sensitivity.endpoint_ms();

        log::info!(
            "Sensitivity updated: threshold={:.2}, endpoint={}ms",
            config.score_threshold,
            config.endpoint_ms
        );
    }

    /// Get current configuration
    pub fn get_config(&self) -> KwsConfig {
        self.config.lock().unwrap().clone()
    }
}

impl Drop for KeywordSpotter {
    fn drop(&mut self) {
        // Cleanup Sherpa-ONNX resources
        unsafe {
            if !self.stream.is_null() {
                SherpaOnnxDestroyOnlineStream(self.stream);
            }
            if !self.kws_handle.is_null() {
                SherpaOnnxDestroyKeywordSpotter(self.kws_handle);
            }
        }
        log::info!("KWS resources released");
    }
}

/// KWS runtime that processes audio and emits events
pub struct KwsRuntime {
    handle: Option<JoinHandle<()>>,
}

impl KwsRuntime {
    /// Start the KWS runtime with given audio source
    pub fn start<A: AudioSource + 'static>(
        mut audio_source: A,
        mut kws: KeywordSpotter,
        app_handle: AppHandle,
    ) -> Self {
        let handle = tokio::spawn(async move {
            log::info!("KWS runtime started");

            let mut frame_count = 0u64;

            loop {
                // Get next audio frame
                if let Some(frame) = audio_source.next_frame() {
                    frame_count += 1;

                    // Process frame
                    let start = Instant::now();
                    if let Some(score) = kws.process_frame(&frame) {
                        let latency = start.elapsed();

                        let config = kws.get_config();
                        let event = WakeWordEvent {
                            keyword: config.keyword.clone(),
                            score,
                        };

                        log::info!(
                            "WAKE WORD DETECTED: '{}' score={:.3} latency={:?}",
                            event.keyword,
                            event.score,
                            latency
                        );

                        // Emit Tauri event
                        if let Err(e) = app_handle.emit("wakeword::detected", &event) {
                            log::error!("Failed to emit event: {}", e);
                        }
                    }

                    if frame_count % 100 == 0 {
                        log::trace!("Processed {} frames", frame_count);
                    }
                } else {
                    // No frame available, yield
                    tokio::time::sleep(Duration::from_millis(1)).await;
                }
            }
        });

        Self {
            handle: Some(handle),
        }
    }

    /// Stop the runtime
    pub fn stop(&mut self) {
        if let Some(handle) = self.handle.take() {
            handle.abort();
            log::info!("KWS runtime stopped");
        }
    }
}

impl Drop for KwsRuntime {
    fn drop(&mut self) {
        self.stop();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sensitivity_levels() {
        assert_eq!(Sensitivity::Low.threshold(), 0.70);
        assert_eq!(Sensitivity::Balanced.threshold(), 0.60);
        assert_eq!(Sensitivity::High.threshold(), 0.50);
    }

    #[test]
    fn test_sensitivity_from_str() {
        assert!(matches!(
            Sensitivity::from_str("low"),
            Some(Sensitivity::Low)
        ));
        assert!(matches!(
            Sensitivity::from_str("balanced"),
            Some(Sensitivity::Balanced)
        ));
        assert!(matches!(
            Sensitivity::from_str("high"),
            Some(Sensitivity::High)
        ));
        assert!(Sensitivity::from_str("invalid").is_none());
    }
}
