/* automatically generated by rust-bindgen 0.70.1 */

#[doc = " Please refer to\n https://k2-fsa.github.io/sherpa/onnx/pretrained_models/index.html\n to download pre-trained models. That is, you can find encoder-xxx.onnx\n decoder-xxx.onnx, joiner-xxx.onnx, and tokens.txt for this struct\n from there."]
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineTransducerModelConfig {
    pub encoder: *const ::std::os::raw::c_char,
    pub decoder: *const ::std::os::raw::c_char,
    pub joiner: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineTransducerModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOnlineTransducerModelConfig>() - 24usize];
    ["Alignment of SherpaOnnxOnlineTransducerModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOnlineTransducerModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineTransducerModelConfig::encoder"]
        [::core::mem::offset_of!(SherpaOnnxOnlineTransducerModelConfig, encoder) - 0usize];
    ["Offset of field: SherpaOnnxOnlineTransducerModelConfig::decoder"]
        [::core::mem::offset_of!(SherpaOnnxOnlineTransducerModelConfig, decoder) - 8usize];
    ["Offset of field: SherpaOnnxOnlineTransducerModelConfig::joiner"]
        [::core::mem::offset_of!(SherpaOnnxOnlineTransducerModelConfig, joiner) - 16usize];
};
impl Default for SherpaOnnxOnlineTransducerModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineParaformerModelConfig {
    pub encoder: *const ::std::os::raw::c_char,
    pub decoder: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineParaformerModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOnlineParaformerModelConfig>() - 16usize];
    ["Alignment of SherpaOnnxOnlineParaformerModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOnlineParaformerModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineParaformerModelConfig::encoder"]
        [::core::mem::offset_of!(SherpaOnnxOnlineParaformerModelConfig, encoder) - 0usize];
    ["Offset of field: SherpaOnnxOnlineParaformerModelConfig::decoder"]
        [::core::mem::offset_of!(SherpaOnnxOnlineParaformerModelConfig, decoder) - 8usize];
};
impl Default for SherpaOnnxOnlineParaformerModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineZipformer2CtcModelConfig {
    pub model: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineZipformer2CtcModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOnlineZipformer2CtcModelConfig>() - 8usize];
    ["Alignment of SherpaOnnxOnlineZipformer2CtcModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOnlineZipformer2CtcModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineZipformer2CtcModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOnlineZipformer2CtcModelConfig, model) - 0usize];
};
impl Default for SherpaOnnxOnlineZipformer2CtcModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineModelConfig {
    pub transducer: SherpaOnnxOnlineTransducerModelConfig,
    pub paraformer: SherpaOnnxOnlineParaformerModelConfig,
    pub zipformer2_ctc: SherpaOnnxOnlineZipformer2CtcModelConfig,
    pub tokens: *const ::std::os::raw::c_char,
    pub num_threads: i32,
    pub provider: *const ::std::os::raw::c_char,
    pub debug: i32,
    pub model_type: *const ::std::os::raw::c_char,
    pub modeling_unit: *const ::std::os::raw::c_char,
    pub bpe_vocab: *const ::std::os::raw::c_char,
    #[doc = " if non-null, loading the tokens from the buffer instead of from the\n \"tokens\" file"]
    pub tokens_buf: *const ::std::os::raw::c_char,
    #[doc = " byte size excluding the trailing '\\0'"]
    pub tokens_buf_size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOnlineModelConfig>() - 120usize];
    ["Alignment of SherpaOnnxOnlineModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOnlineModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::transducer"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, transducer) - 0usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::paraformer"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, paraformer) - 24usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::zipformer2_ctc"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, zipformer2_ctc) - 40usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::tokens"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, tokens) - 48usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, num_threads) - 56usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, provider) - 64usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, debug) - 72usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::model_type"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, model_type) - 80usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::modeling_unit"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, modeling_unit) - 88usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::bpe_vocab"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, bpe_vocab) - 96usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::tokens_buf"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, tokens_buf) - 104usize];
    ["Offset of field: SherpaOnnxOnlineModelConfig::tokens_buf_size"]
        [::core::mem::offset_of!(SherpaOnnxOnlineModelConfig, tokens_buf_size) - 112usize];
};
impl Default for SherpaOnnxOnlineModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " It expects 16 kHz 16-bit single channel wave format."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct SherpaOnnxFeatureConfig {
    #[doc = " Sample rate of the input data. MUST match the one expected\n by the model. For instance, it should be 16000 for models provided\n by us."]
    pub sample_rate: i32,
    #[doc = " Feature dimension of the model.\n For instance, it should be 80 for models provided by us."]
    pub feature_dim: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxFeatureConfig"][::core::mem::size_of::<SherpaOnnxFeatureConfig>() - 8usize];
    ["Alignment of SherpaOnnxFeatureConfig"]
        [::core::mem::align_of::<SherpaOnnxFeatureConfig>() - 4usize];
    ["Offset of field: SherpaOnnxFeatureConfig::sample_rate"]
        [::core::mem::offset_of!(SherpaOnnxFeatureConfig, sample_rate) - 0usize];
    ["Offset of field: SherpaOnnxFeatureConfig::feature_dim"]
        [::core::mem::offset_of!(SherpaOnnxFeatureConfig, feature_dim) - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineCtcFstDecoderConfig {
    pub graph: *const ::std::os::raw::c_char,
    pub max_active: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineCtcFstDecoderConfig"]
        [::core::mem::size_of::<SherpaOnnxOnlineCtcFstDecoderConfig>() - 16usize];
    ["Alignment of SherpaOnnxOnlineCtcFstDecoderConfig"]
        [::core::mem::align_of::<SherpaOnnxOnlineCtcFstDecoderConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineCtcFstDecoderConfig::graph"]
        [::core::mem::offset_of!(SherpaOnnxOnlineCtcFstDecoderConfig, graph) - 0usize];
    ["Offset of field: SherpaOnnxOnlineCtcFstDecoderConfig::max_active"]
        [::core::mem::offset_of!(SherpaOnnxOnlineCtcFstDecoderConfig, max_active) - 8usize];
};
impl Default for SherpaOnnxOnlineCtcFstDecoderConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineRecognizerConfig {
    pub feat_config: SherpaOnnxFeatureConfig,
    pub model_config: SherpaOnnxOnlineModelConfig,
    #[doc = " Possible values are: greedy_search, modified_beam_search"]
    pub decoding_method: *const ::std::os::raw::c_char,
    #[doc = " Used only when decoding_method is modified_beam_search\n Example value: 4"]
    pub max_active_paths: i32,
    #[doc = " 0 to disable endpoint detection.\n A non-zero value to enable endpoint detection."]
    pub enable_endpoint: i32,
    #[doc = " An endpoint is detected if trailing silence in seconds is larger than\n this value even if nothing has been decoded.\n Used only when enable_endpoint is not 0."]
    pub rule1_min_trailing_silence: f32,
    #[doc = " An endpoint is detected if trailing silence in seconds is larger than\n this value after something that is not blank has been decoded.\n Used only when enable_endpoint is not 0."]
    pub rule2_min_trailing_silence: f32,
    #[doc = " An endpoint is detected if the utterance in seconds is larger than\n this value.\n Used only when enable_endpoint is not 0."]
    pub rule3_min_utterance_length: f32,
    #[doc = " Path to the hotwords."]
    pub hotwords_file: *const ::std::os::raw::c_char,
    #[doc = " Bonus score for each token in hotwords."]
    pub hotwords_score: f32,
    pub ctc_fst_decoder_config: SherpaOnnxOnlineCtcFstDecoderConfig,
    pub rule_fsts: *const ::std::os::raw::c_char,
    pub rule_fars: *const ::std::os::raw::c_char,
    pub blank_penalty: f32,
    #[doc = " if non-nullptr, loading the hotwords from the buffered string directly in"]
    pub hotwords_buf: *const ::std::os::raw::c_char,
    #[doc = " byte size excluding the tailing '\\0'"]
    pub hotwords_buf_size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineRecognizerConfig"]
        [::core::mem::size_of::<SherpaOnnxOnlineRecognizerConfig>() - 232usize];
    ["Alignment of SherpaOnnxOnlineRecognizerConfig"]
        [::core::mem::align_of::<SherpaOnnxOnlineRecognizerConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::feat_config"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, feat_config) - 0usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::model_config"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, model_config) - 8usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::decoding_method"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, decoding_method) - 128usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::max_active_paths"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, max_active_paths) - 136usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::enable_endpoint"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, enable_endpoint) - 140usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::rule1_min_trailing_silence"][::core::mem::offset_of!(
        SherpaOnnxOnlineRecognizerConfig,
        rule1_min_trailing_silence
    ) - 144usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::rule2_min_trailing_silence"][::core::mem::offset_of!(
        SherpaOnnxOnlineRecognizerConfig,
        rule2_min_trailing_silence
    ) - 148usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::rule3_min_utterance_length"][::core::mem::offset_of!(
        SherpaOnnxOnlineRecognizerConfig,
        rule3_min_utterance_length
    ) - 152usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::hotwords_file"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, hotwords_file) - 160usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::hotwords_score"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, hotwords_score) - 168usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::ctc_fst_decoder_config"][::core::mem::offset_of!(
        SherpaOnnxOnlineRecognizerConfig,
        ctc_fst_decoder_config
    ) - 176usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::rule_fsts"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, rule_fsts) - 192usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::rule_fars"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, rule_fars) - 200usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::blank_penalty"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, blank_penalty) - 208usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::hotwords_buf"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, hotwords_buf) - 216usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerConfig::hotwords_buf_size"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerConfig, hotwords_buf_size) - 224usize];
};
impl Default for SherpaOnnxOnlineRecognizerConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineRecognizerResult {
    pub text: *const ::std::os::raw::c_char,
    pub tokens: *const ::std::os::raw::c_char,
    pub tokens_arr: *const *const ::std::os::raw::c_char,
    pub timestamps: *mut f32,
    pub count: i32,
    #[doc = " Return a json string.\n\n The returned string contains:\n   {\n     \"text\": \"The recognition result\",\n     \"tokens\": [x, x, x],\n     \"timestamps\": [x, x, x],\n     \"segment\": x,\n     \"start_time\": x,\n     \"is_final\": true|false\n   }"]
    pub json: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOnlineRecognizerResult"]
        [::core::mem::size_of::<SherpaOnnxOnlineRecognizerResult>() - 48usize];
    ["Alignment of SherpaOnnxOnlineRecognizerResult"]
        [::core::mem::align_of::<SherpaOnnxOnlineRecognizerResult>() - 8usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerResult::text"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerResult, text) - 0usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerResult::tokens"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerResult, tokens) - 8usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerResult::tokens_arr"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerResult, tokens_arr) - 16usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerResult::timestamps"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerResult, timestamps) - 24usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerResult::count"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerResult, count) - 32usize];
    ["Offset of field: SherpaOnnxOnlineRecognizerResult::json"]
        [::core::mem::offset_of!(SherpaOnnxOnlineRecognizerResult, json) - 40usize];
};
impl Default for SherpaOnnxOnlineRecognizerResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineRecognizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOnlineStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @param config  Config for the recognizer.\n @return Return a pointer to the recognizer. The user has to invoke"]
    pub fn SherpaOnnxCreateOnlineRecognizer(
        config: *const SherpaOnnxOnlineRecognizerConfig,
    ) -> *const SherpaOnnxOnlineRecognizer;
}
extern "C" {
    #[doc = " Free a pointer returned by SherpaOnnxCreateOnlineRecognizer()\n\n @param p A pointer returned by SherpaOnnxCreateOnlineRecognizer()"]
    pub fn SherpaOnnxDestroyOnlineRecognizer(recognizer: *const SherpaOnnxOnlineRecognizer);
}
extern "C" {
    #[doc = " Create an online stream for accepting wave samples.\n\n @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer()\n @return Return a pointer to an OnlineStream. The user has to invoke\n         SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak."]
    pub fn SherpaOnnxCreateOnlineStream(
        recognizer: *const SherpaOnnxOnlineRecognizer,
    ) -> *const SherpaOnnxOnlineStream;
}
extern "C" {
    #[doc = " Create an online stream for accepting wave samples with the specified hot\n words.\n\n @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer()\n @return Return a pointer to an OnlineStream. The user has to invoke\n         SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak."]
    pub fn SherpaOnnxCreateOnlineStreamWithHotwords(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        hotwords: *const ::std::os::raw::c_char,
    ) -> *const SherpaOnnxOnlineStream;
}
extern "C" {
    #[doc = " Destroy an online stream.\n\n @param stream A pointer returned by SherpaOnnxCreateOnlineStream()"]
    pub fn SherpaOnnxDestroyOnlineStream(stream: *const SherpaOnnxOnlineStream);
}
extern "C" {
    #[doc = " Accept input audio samples and compute the features.\n The user has to invoke SherpaOnnxDecodeOnlineStream() to run the neural\n network and decoding.\n\n @param stream  A pointer returned by SherpaOnnxCreateOnlineStream().\n @param sample_rate  Sample rate of the input samples. If it is different\n                     from config.feat_config.sample_rate, we will do\n                     resampling inside sherpa-onnx.\n @param samples A pointer to a 1-D array containing audio samples.\n                The range of samples has to be normalized to [-1, 1].\n @param n  Number of elements in the samples array."]
    pub fn SherpaOnnxOnlineStreamAcceptWaveform(
        stream: *const SherpaOnnxOnlineStream,
        sample_rate: i32,
        samples: *const f32,
        n: i32,
    );
}
extern "C" {
    #[doc = " Return 1 if there are enough number of feature frames for decoding.\n Return 0 otherwise.\n\n @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer\n @param stream  A pointer returned by SherpaOnnxCreateOnlineStream"]
    pub fn SherpaOnnxIsOnlineStreamReady(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        stream: *const SherpaOnnxOnlineStream,
    ) -> i32;
}
extern "C" {
    #[doc = " Precondition for this function: SherpaOnnxIsOnlineStreamReady() MUST\n return 1.\n\n Usage example:\n\n  while (SherpaOnnxIsOnlineStreamReady(recognizer, stream)) {\n     SherpaOnnxDecodeOnlineStream(recognizer, stream);\n  }\n"]
    pub fn SherpaOnnxDecodeOnlineStream(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        stream: *const SherpaOnnxOnlineStream,
    );
}
extern "C" {
    #[doc = " This function is similar to SherpaOnnxDecodeOnlineStream(). It decodes\n multiple OnlineStream in parallel.\n\n Caution: The caller has to ensure each OnlineStream is ready, i.e.,\n SherpaOnnxIsOnlineStreamReady() for that stream should return 1.\n\n @param recognizer  A pointer returned by SherpaOnnxCreateOnlineRecognizer()\n @param streams  A pointer array containing pointers returned by\n                 SherpaOnnxCreateOnlineRecognizer()\n @param n  Number of elements in the given streams array."]
    pub fn SherpaOnnxDecodeMultipleOnlineStreams(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        streams: *mut *const SherpaOnnxOnlineStream,
        n: i32,
    );
}
extern "C" {
    #[doc = " Get the decoding results so far for an OnlineStream.\n\n @param recognizer A pointer returned by SherpaOnnxCreateOnlineRecognizer().\n @param stream A pointer returned by SherpaOnnxCreateOnlineStream().\n @return A pointer containing the result. The user has to invoke\n         SherpaOnnxDestroyOnlineRecognizerResult() to free the returned\n         pointer to avoid memory leak."]
    pub fn SherpaOnnxGetOnlineStreamResult(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        stream: *const SherpaOnnxOnlineStream,
    ) -> *const SherpaOnnxOnlineRecognizerResult;
}
extern "C" {
    #[doc = " Destroy the pointer returned by SherpaOnnxGetOnlineStreamResult().\n\n @param r A pointer returned by SherpaOnnxGetOnlineStreamResult()"]
    pub fn SherpaOnnxDestroyOnlineRecognizerResult(r: *const SherpaOnnxOnlineRecognizerResult);
}
extern "C" {
    #[doc = " Return the result as a json string.\n The user has to invoke\n SherpaOnnxDestroyOnlineStreamResultJson()\n to free the returned pointer to avoid memory leak"]
    pub fn SherpaOnnxGetOnlineStreamResultAsJson(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        stream: *const SherpaOnnxOnlineStream,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SherpaOnnxDestroyOnlineStreamResultJson(s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " SherpaOnnxOnlineStreamReset an OnlineStream , which clears the neural\n network model state and the state for decoding.\n\n @param recognizer A pointer returned by SherpaOnnxCreateOnlineRecognizer().\n @param stream A pointer returned by SherpaOnnxCreateOnlineStream"]
    pub fn SherpaOnnxOnlineStreamReset(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        stream: *const SherpaOnnxOnlineStream,
    );
}
extern "C" {
    #[doc = " Signal that no more audio samples would be available.\n After this call, you cannot call SherpaOnnxOnlineStreamAcceptWaveform() any\n more.\n\n @param stream A pointer returned by SherpaOnnxCreateOnlineStream()"]
    pub fn SherpaOnnxOnlineStreamInputFinished(stream: *const SherpaOnnxOnlineStream);
}
extern "C" {
    #[doc = " Return 1 if an endpoint has been detected.\n\n @param recognizer A pointer returned by SherpaOnnxCreateOnlineRecognizer()\n @param stream A pointer returned by SherpaOnnxCreateOnlineStream()\n @return Return 1 if an endpoint is detected. Return 0 otherwise."]
    pub fn SherpaOnnxOnlineStreamIsEndpoint(
        recognizer: *const SherpaOnnxOnlineRecognizer,
        stream: *const SherpaOnnxOnlineStream,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxDisplay {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a display object. Must be freed using SherpaOnnxDestroyDisplay to\n avoid memory leak."]
    pub fn SherpaOnnxCreateDisplay(max_word_per_line: i32) -> *const SherpaOnnxDisplay;
}
extern "C" {
    pub fn SherpaOnnxDestroyDisplay(display: *const SherpaOnnxDisplay);
}
extern "C" {
    #[doc = " Print the result."]
    pub fn SherpaOnnxPrint(
        display: *const SherpaOnnxDisplay,
        idx: i32,
        s: *const ::std::os::raw::c_char,
    );
}
#[doc = " Please refer to\n https://k2-fsa.github.io/sherpa/onnx/pretrained_models/index.html\n to download pre-trained models. That is, you can find encoder-xxx.onnx\n decoder-xxx.onnx, and joiner-xxx.onnx for this struct\n from there."]
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineTransducerModelConfig {
    pub encoder: *const ::std::os::raw::c_char,
    pub decoder: *const ::std::os::raw::c_char,
    pub joiner: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineTransducerModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineTransducerModelConfig>() - 24usize];
    ["Alignment of SherpaOnnxOfflineTransducerModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineTransducerModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineTransducerModelConfig::encoder"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTransducerModelConfig, encoder) - 0usize];
    ["Offset of field: SherpaOnnxOfflineTransducerModelConfig::decoder"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTransducerModelConfig, decoder) - 8usize];
    ["Offset of field: SherpaOnnxOfflineTransducerModelConfig::joiner"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTransducerModelConfig, joiner) - 16usize];
};
impl Default for SherpaOnnxOfflineTransducerModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineParaformerModelConfig {
    pub model: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineParaformerModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineParaformerModelConfig>() - 8usize];
    ["Alignment of SherpaOnnxOfflineParaformerModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineParaformerModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineParaformerModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineParaformerModelConfig, model) - 0usize];
};
impl Default for SherpaOnnxOfflineParaformerModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineNemoEncDecCtcModelConfig {
    pub model: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineNemoEncDecCtcModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineNemoEncDecCtcModelConfig>() - 8usize];
    ["Alignment of SherpaOnnxOfflineNemoEncDecCtcModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineNemoEncDecCtcModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineNemoEncDecCtcModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineNemoEncDecCtcModelConfig, model) - 0usize];
};
impl Default for SherpaOnnxOfflineNemoEncDecCtcModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineWhisperModelConfig {
    pub encoder: *const ::std::os::raw::c_char,
    pub decoder: *const ::std::os::raw::c_char,
    pub language: *const ::std::os::raw::c_char,
    pub task: *const ::std::os::raw::c_char,
    pub tail_paddings: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineWhisperModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineWhisperModelConfig>() - 40usize];
    ["Alignment of SherpaOnnxOfflineWhisperModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineWhisperModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineWhisperModelConfig::encoder"]
        [::core::mem::offset_of!(SherpaOnnxOfflineWhisperModelConfig, encoder) - 0usize];
    ["Offset of field: SherpaOnnxOfflineWhisperModelConfig::decoder"]
        [::core::mem::offset_of!(SherpaOnnxOfflineWhisperModelConfig, decoder) - 8usize];
    ["Offset of field: SherpaOnnxOfflineWhisperModelConfig::language"]
        [::core::mem::offset_of!(SherpaOnnxOfflineWhisperModelConfig, language) - 16usize];
    ["Offset of field: SherpaOnnxOfflineWhisperModelConfig::task"]
        [::core::mem::offset_of!(SherpaOnnxOfflineWhisperModelConfig, task) - 24usize];
    ["Offset of field: SherpaOnnxOfflineWhisperModelConfig::tail_paddings"]
        [::core::mem::offset_of!(SherpaOnnxOfflineWhisperModelConfig, tail_paddings) - 32usize];
};
impl Default for SherpaOnnxOfflineWhisperModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineMoonshineModelConfig {
    pub preprocessor: *const ::std::os::raw::c_char,
    pub encoder: *const ::std::os::raw::c_char,
    pub uncached_decoder: *const ::std::os::raw::c_char,
    pub cached_decoder: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineMoonshineModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineMoonshineModelConfig>() - 32usize];
    ["Alignment of SherpaOnnxOfflineMoonshineModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineMoonshineModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineMoonshineModelConfig::preprocessor"]
        [::core::mem::offset_of!(SherpaOnnxOfflineMoonshineModelConfig, preprocessor) - 0usize];
    ["Offset of field: SherpaOnnxOfflineMoonshineModelConfig::encoder"]
        [::core::mem::offset_of!(SherpaOnnxOfflineMoonshineModelConfig, encoder) - 8usize];
    ["Offset of field: SherpaOnnxOfflineMoonshineModelConfig::uncached_decoder"][::core::mem::offset_of!(
        SherpaOnnxOfflineMoonshineModelConfig,
        uncached_decoder
    ) - 16usize];
    ["Offset of field: SherpaOnnxOfflineMoonshineModelConfig::cached_decoder"]
        [::core::mem::offset_of!(SherpaOnnxOfflineMoonshineModelConfig, cached_decoder) - 24usize];
};
impl Default for SherpaOnnxOfflineMoonshineModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineTdnnModelConfig {
    pub model: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineTdnnModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineTdnnModelConfig>() - 8usize];
    ["Alignment of SherpaOnnxOfflineTdnnModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineTdnnModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineTdnnModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTdnnModelConfig, model) - 0usize];
};
impl Default for SherpaOnnxOfflineTdnnModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineLMConfig {
    pub model: *const ::std::os::raw::c_char,
    pub scale: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineLMConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineLMConfig>() - 16usize];
    ["Alignment of SherpaOnnxOfflineLMConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineLMConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineLMConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineLMConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxOfflineLMConfig::scale"]
        [::core::mem::offset_of!(SherpaOnnxOfflineLMConfig, scale) - 8usize];
};
impl Default for SherpaOnnxOfflineLMConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineSenseVoiceModelConfig {
    pub model: *const ::std::os::raw::c_char,
    pub language: *const ::std::os::raw::c_char,
    pub use_itn: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineSenseVoiceModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineSenseVoiceModelConfig>() - 24usize];
    ["Alignment of SherpaOnnxOfflineSenseVoiceModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineSenseVoiceModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineSenseVoiceModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSenseVoiceModelConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxOfflineSenseVoiceModelConfig::language"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSenseVoiceModelConfig, language) - 8usize];
    ["Offset of field: SherpaOnnxOfflineSenseVoiceModelConfig::use_itn"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSenseVoiceModelConfig, use_itn) - 16usize];
};
impl Default for SherpaOnnxOfflineSenseVoiceModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineModelConfig {
    pub transducer: SherpaOnnxOfflineTransducerModelConfig,
    pub paraformer: SherpaOnnxOfflineParaformerModelConfig,
    pub nemo_ctc: SherpaOnnxOfflineNemoEncDecCtcModelConfig,
    pub whisper: SherpaOnnxOfflineWhisperModelConfig,
    pub tdnn: SherpaOnnxOfflineTdnnModelConfig,
    pub tokens: *const ::std::os::raw::c_char,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
    pub model_type: *const ::std::os::raw::c_char,
    pub modeling_unit: *const ::std::os::raw::c_char,
    pub bpe_vocab: *const ::std::os::raw::c_char,
    pub telespeech_ctc: *const ::std::os::raw::c_char,
    pub sense_voice: SherpaOnnxOfflineSenseVoiceModelConfig,
    pub moonshine: SherpaOnnxOfflineMoonshineModelConfig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineModelConfig>() - 200usize];
    ["Alignment of SherpaOnnxOfflineModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::transducer"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, transducer) - 0usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::paraformer"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, paraformer) - 24usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::nemo_ctc"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, nemo_ctc) - 32usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::whisper"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, whisper) - 40usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::tdnn"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, tdnn) - 80usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::tokens"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, tokens) - 88usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, num_threads) - 96usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, debug) - 100usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, provider) - 104usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::model_type"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, model_type) - 112usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::modeling_unit"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, modeling_unit) - 120usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::bpe_vocab"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, bpe_vocab) - 128usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::telespeech_ctc"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, telespeech_ctc) - 136usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::sense_voice"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, sense_voice) - 144usize];
    ["Offset of field: SherpaOnnxOfflineModelConfig::moonshine"]
        [::core::mem::offset_of!(SherpaOnnxOfflineModelConfig, moonshine) - 168usize];
};
impl Default for SherpaOnnxOfflineModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineRecognizerConfig {
    pub feat_config: SherpaOnnxFeatureConfig,
    pub model_config: SherpaOnnxOfflineModelConfig,
    pub lm_config: SherpaOnnxOfflineLMConfig,
    pub decoding_method: *const ::std::os::raw::c_char,
    pub max_active_paths: i32,
    #[doc = " Path to the hotwords."]
    pub hotwords_file: *const ::std::os::raw::c_char,
    #[doc = " Bonus score for each token in hotwords."]
    pub hotwords_score: f32,
    pub rule_fsts: *const ::std::os::raw::c_char,
    pub rule_fars: *const ::std::os::raw::c_char,
    pub blank_penalty: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineRecognizerConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineRecognizerConfig>() - 280usize];
    ["Alignment of SherpaOnnxOfflineRecognizerConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineRecognizerConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::feat_config"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, feat_config) - 0usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::model_config"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, model_config) - 8usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::lm_config"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, lm_config) - 208usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::decoding_method"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, decoding_method) - 224usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::max_active_paths"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, max_active_paths) - 232usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::hotwords_file"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, hotwords_file) - 240usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::hotwords_score"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, hotwords_score) - 248usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::rule_fsts"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, rule_fsts) - 256usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::rule_fars"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, rule_fars) - 264usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerConfig::blank_penalty"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerConfig, blank_penalty) - 272usize];
};
impl Default for SherpaOnnxOfflineRecognizerConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineRecognizer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @param config  Config for the recognizer.\n @return Return a pointer to the recognizer. The user has to invoke"]
    pub fn SherpaOnnxCreateOfflineRecognizer(
        config: *const SherpaOnnxOfflineRecognizerConfig,
    ) -> *const SherpaOnnxOfflineRecognizer;
}
extern "C" {
    #[doc = " @param config  Config for the recognizer."]
    pub fn SherpaOnnxOfflineRecognizerSetConfig(
        recognizer: *const SherpaOnnxOfflineRecognizer,
        config: *const SherpaOnnxOfflineRecognizerConfig,
    );
}
extern "C" {
    #[doc = " Free a pointer returned by SherpaOnnxCreateOfflineRecognizer()\n\n @param p A pointer returned by SherpaOnnxCreateOfflineRecognizer()"]
    pub fn SherpaOnnxDestroyOfflineRecognizer(recognizer: *const SherpaOnnxOfflineRecognizer);
}
extern "C" {
    #[doc = " Create an offline stream for accepting wave samples.\n\n @param recognizer  A pointer returned by SherpaOnnxCreateOfflineRecognizer()\n @return Return a pointer to an OfflineStream. The user has to invoke\n         SherpaOnnxDestroyOfflineStream() to free it to avoid memory leak."]
    pub fn SherpaOnnxCreateOfflineStream(
        recognizer: *const SherpaOnnxOfflineRecognizer,
    ) -> *const SherpaOnnxOfflineStream;
}
extern "C" {
    #[doc = " Destroy an offline stream.\n\n @param stream A pointer returned by SherpaOnnxCreateOfflineStream()"]
    pub fn SherpaOnnxDestroyOfflineStream(stream: *const SherpaOnnxOfflineStream);
}
extern "C" {
    #[doc = " Accept input audio samples and compute the features.\n The user has to invoke SherpaOnnxDecodeOfflineStream() to run the neural\n network and decoding.\n\n @param stream  A pointer returned by SherpaOnnxCreateOfflineStream().\n @param sample_rate  Sample rate of the input samples. If it is different\n                     from config.feat_config.sample_rate, we will do\n                     resampling inside sherpa-onnx.\n @param samples A pointer to a 1-D array containing audio samples.\n                The range of samples has to be normalized to [-1, 1].\n @param n  Number of elements in the samples array.\n\n @caution: For each offline stream, please invoke this function only once!"]
    pub fn SherpaOnnxAcceptWaveformOffline(
        stream: *const SherpaOnnxOfflineStream,
        sample_rate: i32,
        samples: *const f32,
        n: i32,
    );
}
extern "C" {
    #[doc = " Decode an offline stream.\n\n We assume you have invoked SherpaOnnxAcceptWaveformOffline() for the given\n stream before calling this function.\n\n @param recognizer A pointer returned by SherpaOnnxCreateOfflineRecognizer().\n @param stream A pointer returned by SherpaOnnxCreateOfflineStream()"]
    pub fn SherpaOnnxDecodeOfflineStream(
        recognizer: *const SherpaOnnxOfflineRecognizer,
        stream: *const SherpaOnnxOfflineStream,
    );
}
extern "C" {
    #[doc = " Decode a list offline streams in parallel.\n\n We assume you have invoked SherpaOnnxAcceptWaveformOffline() for each stream\n before calling this function.\n\n @param recognizer A pointer returned by SherpaOnnxCreateOfflineRecognizer().\n @param streams A pointer pointer array containing pointers returned\n                by SherpaOnnxCreateOfflineStream().\n @param n Number of entries in the given streams."]
    pub fn SherpaOnnxDecodeMultipleOfflineStreams(
        recognizer: *const SherpaOnnxOfflineRecognizer,
        streams: *mut *const SherpaOnnxOfflineStream,
        n: i32,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineRecognizerResult {
    pub text: *const ::std::os::raw::c_char,
    pub timestamps: *mut f32,
    pub count: i32,
    pub tokens: *const ::std::os::raw::c_char,
    pub tokens_arr: *const *const ::std::os::raw::c_char,
    #[doc = " Return a json string.\n\n The returned string contains:\n   {\n     \"text\": \"The recognition result\",\n     \"tokens\": [x, x, x],\n     \"timestamps\": [x, x, x],\n     \"segment\": x,\n     \"start_time\": x,\n     \"is_final\": true|false\n   }"]
    pub json: *const ::std::os::raw::c_char,
    pub lang: *const ::std::os::raw::c_char,
    pub emotion: *const ::std::os::raw::c_char,
    pub event: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineRecognizerResult"]
        [::core::mem::size_of::<SherpaOnnxOfflineRecognizerResult>() - 72usize];
    ["Alignment of SherpaOnnxOfflineRecognizerResult"]
        [::core::mem::align_of::<SherpaOnnxOfflineRecognizerResult>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::text"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, text) - 0usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::timestamps"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, timestamps) - 8usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::count"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, count) - 16usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::tokens"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, tokens) - 24usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::tokens_arr"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, tokens_arr) - 32usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::json"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, json) - 40usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::lang"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, lang) - 48usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::emotion"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, emotion) - 56usize];
    ["Offset of field: SherpaOnnxOfflineRecognizerResult::event"]
        [::core::mem::offset_of!(SherpaOnnxOfflineRecognizerResult, event) - 64usize];
};
impl Default for SherpaOnnxOfflineRecognizerResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get the result of the offline stream.\n\n We assume you have called SherpaOnnxDecodeOfflineStream() or\n SherpaOnnxDecodeMultipleOfflineStreams() with the given stream before\n calling this function.\n\n @param stream A pointer returned by SherpaOnnxCreateOfflineStream().\n @return Return a pointer to the result. The user has to invoke\n         SherpaOnnxDestroyOnlineRecognizerResult() to free the returned\n         pointer to avoid memory leak."]
    pub fn SherpaOnnxGetOfflineStreamResult(
        stream: *const SherpaOnnxOfflineStream,
    ) -> *const SherpaOnnxOfflineRecognizerResult;
}
extern "C" {
    #[doc = " Destroy the pointer returned by SherpaOnnxGetOfflineStreamResult().\n\n @param r A pointer returned by SherpaOnnxGetOfflineStreamResult()"]
    pub fn SherpaOnnxDestroyOfflineRecognizerResult(r: *const SherpaOnnxOfflineRecognizerResult);
}
extern "C" {
    #[doc = " Return the result as a json string.\n The user has to use SherpaOnnxDestroyOfflineStreamResultJson()\n to free the returned pointer to avoid memory leak"]
    pub fn SherpaOnnxGetOfflineStreamResultAsJson(
        stream: *const SherpaOnnxOfflineStream,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SherpaOnnxDestroyOfflineStreamResultJson(s: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxKeywordResult {
    #[doc = " The triggered keyword.\n For English, it consists of space separated words.\n For Chinese, it consists of Chinese words without spaces.\n Example 1: \"hello world\"\n Example 2: \"你好世界\""]
    pub keyword: *const ::std::os::raw::c_char,
    #[doc = " Decoded results at the token level.\n For instance, for BPE-based models it consists of a list of BPE tokens."]
    pub tokens: *const ::std::os::raw::c_char,
    pub tokens_arr: *const *const ::std::os::raw::c_char,
    pub count: i32,
    #[doc = " timestamps.size() == tokens.size()\n timestamps[i] records the time in seconds when tokens[i] is decoded."]
    pub timestamps: *mut f32,
    #[doc = " Starting time of this segment.\n When an endpoint is detected, it will change"]
    pub start_time: f32,
    #[doc = " Return a json string.\n\n The returned string contains:\n   {\n     \"keyword\": \"The triggered keyword\",\n     \"tokens\": [x, x, x],\n     \"timestamps\": [x, x, x],\n     \"start_time\": x,\n   }"]
    pub json: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxKeywordResult"]
        [::core::mem::size_of::<SherpaOnnxKeywordResult>() - 56usize];
    ["Alignment of SherpaOnnxKeywordResult"]
        [::core::mem::align_of::<SherpaOnnxKeywordResult>() - 8usize];
    ["Offset of field: SherpaOnnxKeywordResult::keyword"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, keyword) - 0usize];
    ["Offset of field: SherpaOnnxKeywordResult::tokens"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, tokens) - 8usize];
    ["Offset of field: SherpaOnnxKeywordResult::tokens_arr"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, tokens_arr) - 16usize];
    ["Offset of field: SherpaOnnxKeywordResult::count"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, count) - 24usize];
    ["Offset of field: SherpaOnnxKeywordResult::timestamps"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, timestamps) - 32usize];
    ["Offset of field: SherpaOnnxKeywordResult::start_time"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, start_time) - 40usize];
    ["Offset of field: SherpaOnnxKeywordResult::json"]
        [::core::mem::offset_of!(SherpaOnnxKeywordResult, json) - 48usize];
};
impl Default for SherpaOnnxKeywordResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxKeywordSpotterConfig {
    pub feat_config: SherpaOnnxFeatureConfig,
    pub model_config: SherpaOnnxOnlineModelConfig,
    pub max_active_paths: i32,
    pub num_trailing_blanks: i32,
    pub keywords_score: f32,
    pub keywords_threshold: f32,
    pub keywords_file: *const ::std::os::raw::c_char,
    #[doc = " if non-null, loading the keywords from the buffer instead of from the\n keywords_file"]
    pub keywords_buf: *const ::std::os::raw::c_char,
    #[doc = " byte size excluding the trailing '\\0'"]
    pub keywords_buf_size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxKeywordSpotterConfig"]
        [::core::mem::size_of::<SherpaOnnxKeywordSpotterConfig>() - 168usize];
    ["Alignment of SherpaOnnxKeywordSpotterConfig"]
        [::core::mem::align_of::<SherpaOnnxKeywordSpotterConfig>() - 8usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::feat_config"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, feat_config) - 0usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::model_config"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, model_config) - 8usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::max_active_paths"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, max_active_paths) - 128usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::num_trailing_blanks"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, num_trailing_blanks) - 132usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::keywords_score"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, keywords_score) - 136usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::keywords_threshold"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, keywords_threshold) - 140usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::keywords_file"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, keywords_file) - 144usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::keywords_buf"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, keywords_buf) - 152usize];
    ["Offset of field: SherpaOnnxKeywordSpotterConfig::keywords_buf_size"]
        [::core::mem::offset_of!(SherpaOnnxKeywordSpotterConfig, keywords_buf_size) - 160usize];
};
impl Default for SherpaOnnxKeywordSpotterConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxKeywordSpotter {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @param config  Config for the keyword spotter.\n @return Return a pointer to the spotter. The user has to invoke\n         SherpaOnnxDestroyKeywordSpotter() to free it to avoid memory leak."]
    pub fn SherpaOnnxCreateKeywordSpotter(
        config: *const SherpaOnnxKeywordSpotterConfig,
    ) -> *mut SherpaOnnxKeywordSpotter;
}
extern "C" {
    #[doc = " Free a pointer returned by SherpaOnnxCreateKeywordSpotter()\n\n @param p A pointer returned by SherpaOnnxCreateKeywordSpotter()"]
    pub fn SherpaOnnxDestroyKeywordSpotter(spotter: *mut SherpaOnnxKeywordSpotter);
}
extern "C" {
    #[doc = " Create an online stream for accepting wave samples.\n\n @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter()\n @return Return a pointer to an OnlineStream. The user has to invoke\n         SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak."]
    pub fn SherpaOnnxCreateKeywordStream(
        spotter: *const SherpaOnnxKeywordSpotter,
    ) -> *mut SherpaOnnxOnlineStream;
}
extern "C" {
    #[doc = " Create an online stream for accepting wave samples with the specified hot\n words.\n\n @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter()\n @param keywords A pointer points to the keywords that you set\n @return Return a pointer to an OnlineStream. The user has to invoke\n         SherpaOnnxDestroyOnlineStream() to free it to avoid memory leak."]
    pub fn SherpaOnnxCreateKeywordStreamWithKeywords(
        spotter: *const SherpaOnnxKeywordSpotter,
        keywords: *const ::std::os::raw::c_char,
    ) -> *mut SherpaOnnxOnlineStream;
}
extern "C" {
    #[doc = " Return 1 if there are enough number of feature frames for decoding.\n Return 0 otherwise.\n\n @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter\n @param stream  A pointer returned by SherpaOnnxCreateKeywordStream"]
    pub fn SherpaOnnxIsKeywordStreamReady(
        spotter: *mut SherpaOnnxKeywordSpotter,
        stream: *mut SherpaOnnxOnlineStream,
    ) -> i32;
}
extern "C" {
    #[doc = " Precondition for this function: SherpaOnnxIsKeywordStreamReady() MUST\n return 1."]
    pub fn SherpaOnnxDecodeKeywordStream(
        spotter: *mut SherpaOnnxKeywordSpotter,
        stream: *mut SherpaOnnxOnlineStream,
    );
}
extern "C" {
    #[doc = " This function is similar to SherpaOnnxDecodeKeywordStream(). It decodes\n multiple OnlineStream in parallel.\n\n Caution: The caller has to ensure each OnlineStream is ready, i.e.,\n SherpaOnnxIsKeywordStreamReady() for that stream should return 1.\n\n @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter()\n @param streams  A pointer array containing pointers returned by\n                 SherpaOnnxCreateKeywordStream()\n @param n  Number of elements in the given streams array."]
    pub fn SherpaOnnxDecodeMultipleKeywordStreams(
        spotter: *mut SherpaOnnxKeywordSpotter,
        streams: *mut *mut SherpaOnnxOnlineStream,
        n: i32,
    );
}
extern "C" {
    #[doc = " Get the decoding results so far for an OnlineStream.\n\n @param spotter A pointer returned by SherpaOnnxCreateKeywordSpotter().\n @param stream A pointer returned by SherpaOnnxCreateKeywordStream().\n @return A pointer containing the result. The user has to invoke\n         SherpaOnnxDestroyKeywordResult() to free the returned pointer to\n         avoid memory leak."]
    pub fn SherpaOnnxGetKeywordResult(
        spotter: *mut SherpaOnnxKeywordSpotter,
        stream: *mut SherpaOnnxOnlineStream,
    ) -> *const SherpaOnnxKeywordResult;
}
extern "C" {
    #[doc = " Destroy the pointer returned by SherpaOnnxGetKeywordResult().\n\n @param r A pointer returned by SherpaOnnxGetKeywordResult()"]
    pub fn SherpaOnnxDestroyKeywordResult(r: *const SherpaOnnxKeywordResult);
}
extern "C" {
    pub fn SherpaOnnxGetKeywordResultAsJson(
        spotter: *mut SherpaOnnxKeywordSpotter,
        stream: *mut SherpaOnnxOnlineStream,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SherpaOnnxFreeKeywordResultJson(s: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSileroVadModelConfig {
    pub model: *const ::std::os::raw::c_char,
    pub threshold: f32,
    pub min_silence_duration: f32,
    pub min_speech_duration: f32,
    pub window_size: ::std::os::raw::c_int,
    pub max_speech_duration: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSileroVadModelConfig"]
        [::core::mem::size_of::<SherpaOnnxSileroVadModelConfig>() - 32usize];
    ["Alignment of SherpaOnnxSileroVadModelConfig"]
        [::core::mem::align_of::<SherpaOnnxSileroVadModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxSileroVadModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxSileroVadModelConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxSileroVadModelConfig::threshold"]
        [::core::mem::offset_of!(SherpaOnnxSileroVadModelConfig, threshold) - 8usize];
    ["Offset of field: SherpaOnnxSileroVadModelConfig::min_silence_duration"]
        [::core::mem::offset_of!(SherpaOnnxSileroVadModelConfig, min_silence_duration) - 12usize];
    ["Offset of field: SherpaOnnxSileroVadModelConfig::min_speech_duration"]
        [::core::mem::offset_of!(SherpaOnnxSileroVadModelConfig, min_speech_duration) - 16usize];
    ["Offset of field: SherpaOnnxSileroVadModelConfig::window_size"]
        [::core::mem::offset_of!(SherpaOnnxSileroVadModelConfig, window_size) - 20usize];
    ["Offset of field: SherpaOnnxSileroVadModelConfig::max_speech_duration"]
        [::core::mem::offset_of!(SherpaOnnxSileroVadModelConfig, max_speech_duration) - 24usize];
};
impl Default for SherpaOnnxSileroVadModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxVadModelConfig {
    pub silero_vad: SherpaOnnxSileroVadModelConfig,
    pub sample_rate: i32,
    pub num_threads: i32,
    pub provider: *const ::std::os::raw::c_char,
    pub debug: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxVadModelConfig"]
        [::core::mem::size_of::<SherpaOnnxVadModelConfig>() - 56usize];
    ["Alignment of SherpaOnnxVadModelConfig"]
        [::core::mem::align_of::<SherpaOnnxVadModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxVadModelConfig::silero_vad"]
        [::core::mem::offset_of!(SherpaOnnxVadModelConfig, silero_vad) - 0usize];
    ["Offset of field: SherpaOnnxVadModelConfig::sample_rate"]
        [::core::mem::offset_of!(SherpaOnnxVadModelConfig, sample_rate) - 32usize];
    ["Offset of field: SherpaOnnxVadModelConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxVadModelConfig, num_threads) - 36usize];
    ["Offset of field: SherpaOnnxVadModelConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxVadModelConfig, provider) - 40usize];
    ["Offset of field: SherpaOnnxVadModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxVadModelConfig, debug) - 48usize];
};
impl Default for SherpaOnnxVadModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxCircularBuffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateCircularBuffer(capacity: i32) -> *mut SherpaOnnxCircularBuffer;
}
extern "C" {
    pub fn SherpaOnnxDestroyCircularBuffer(buffer: *mut SherpaOnnxCircularBuffer);
}
extern "C" {
    pub fn SherpaOnnxCircularBufferPush(
        buffer: *mut SherpaOnnxCircularBuffer,
        p: *const f32,
        n: i32,
    );
}
extern "C" {
    pub fn SherpaOnnxCircularBufferGet(
        buffer: *mut SherpaOnnxCircularBuffer,
        start_index: i32,
        n: i32,
    ) -> *const f32;
}
extern "C" {
    pub fn SherpaOnnxCircularBufferFree(p: *const f32);
}
extern "C" {
    pub fn SherpaOnnxCircularBufferPop(buffer: *mut SherpaOnnxCircularBuffer, n: i32);
}
extern "C" {
    pub fn SherpaOnnxCircularBufferSize(buffer: *mut SherpaOnnxCircularBuffer) -> i32;
}
extern "C" {
    pub fn SherpaOnnxCircularBufferHead(buffer: *mut SherpaOnnxCircularBuffer) -> i32;
}
extern "C" {
    pub fn SherpaOnnxCircularBufferReset(buffer: *mut SherpaOnnxCircularBuffer);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpeechSegment {
    pub start: i32,
    pub samples: *mut f32,
    pub n: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpeechSegment"]
        [::core::mem::size_of::<SherpaOnnxSpeechSegment>() - 24usize];
    ["Alignment of SherpaOnnxSpeechSegment"]
        [::core::mem::align_of::<SherpaOnnxSpeechSegment>() - 8usize];
    ["Offset of field: SherpaOnnxSpeechSegment::start"]
        [::core::mem::offset_of!(SherpaOnnxSpeechSegment, start) - 0usize];
    ["Offset of field: SherpaOnnxSpeechSegment::samples"]
        [::core::mem::offset_of!(SherpaOnnxSpeechSegment, samples) - 8usize];
    ["Offset of field: SherpaOnnxSpeechSegment::n"]
        [::core::mem::offset_of!(SherpaOnnxSpeechSegment, n) - 16usize];
};
impl Default for SherpaOnnxSpeechSegment {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxVoiceActivityDetector {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateVoiceActivityDetector(
        config: *const SherpaOnnxVadModelConfig,
        buffer_size_in_seconds: f32,
    ) -> *mut SherpaOnnxVoiceActivityDetector;
}
extern "C" {
    pub fn SherpaOnnxDestroyVoiceActivityDetector(p: *mut SherpaOnnxVoiceActivityDetector);
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorAcceptWaveform(
        p: *mut SherpaOnnxVoiceActivityDetector,
        samples: *const f32,
        n: i32,
    );
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorEmpty(p: *mut SherpaOnnxVoiceActivityDetector) -> i32;
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorDetected(p: *mut SherpaOnnxVoiceActivityDetector) -> i32;
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorPop(p: *mut SherpaOnnxVoiceActivityDetector);
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorClear(p: *mut SherpaOnnxVoiceActivityDetector);
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorFront(
        p: *mut SherpaOnnxVoiceActivityDetector,
    ) -> *const SherpaOnnxSpeechSegment;
}
extern "C" {
    pub fn SherpaOnnxDestroySpeechSegment(p: *const SherpaOnnxSpeechSegment);
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorReset(p: *mut SherpaOnnxVoiceActivityDetector);
}
extern "C" {
    pub fn SherpaOnnxVoiceActivityDetectorFlush(p: *mut SherpaOnnxVoiceActivityDetector);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineTtsVitsModelConfig {
    pub model: *const ::std::os::raw::c_char,
    pub lexicon: *const ::std::os::raw::c_char,
    pub tokens: *const ::std::os::raw::c_char,
    pub data_dir: *const ::std::os::raw::c_char,
    pub noise_scale: f32,
    pub noise_scale_w: f32,
    pub length_scale: f32,
    pub dict_dir: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineTtsVitsModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineTtsVitsModelConfig>() - 56usize];
    ["Alignment of SherpaOnnxOfflineTtsVitsModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineTtsVitsModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::lexicon"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, lexicon) - 8usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::tokens"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, tokens) - 16usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::data_dir"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, data_dir) - 24usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::noise_scale"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, noise_scale) - 32usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::noise_scale_w"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, noise_scale_w) - 36usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::length_scale"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, length_scale) - 40usize];
    ["Offset of field: SherpaOnnxOfflineTtsVitsModelConfig::dict_dir"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsVitsModelConfig, dict_dir) - 48usize];
};
impl Default for SherpaOnnxOfflineTtsVitsModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineTtsModelConfig {
    pub vits: SherpaOnnxOfflineTtsVitsModelConfig,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineTtsModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineTtsModelConfig>() - 72usize];
    ["Alignment of SherpaOnnxOfflineTtsModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineTtsModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineTtsModelConfig::vits"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsModelConfig, vits) - 0usize];
    ["Offset of field: SherpaOnnxOfflineTtsModelConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsModelConfig, num_threads) - 56usize];
    ["Offset of field: SherpaOnnxOfflineTtsModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsModelConfig, debug) - 60usize];
    ["Offset of field: SherpaOnnxOfflineTtsModelConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsModelConfig, provider) - 64usize];
};
impl Default for SherpaOnnxOfflineTtsModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineTtsConfig {
    pub model: SherpaOnnxOfflineTtsModelConfig,
    pub rule_fsts: *const ::std::os::raw::c_char,
    pub max_num_sentences: i32,
    pub rule_fars: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineTtsConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineTtsConfig>() - 96usize];
    ["Alignment of SherpaOnnxOfflineTtsConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineTtsConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineTtsConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxOfflineTtsConfig::rule_fsts"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsConfig, rule_fsts) - 72usize];
    ["Offset of field: SherpaOnnxOfflineTtsConfig::max_num_sentences"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsConfig, max_num_sentences) - 80usize];
    ["Offset of field: SherpaOnnxOfflineTtsConfig::rule_fars"]
        [::core::mem::offset_of!(SherpaOnnxOfflineTtsConfig, rule_fars) - 88usize];
};
impl Default for SherpaOnnxOfflineTtsConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxGeneratedAudio {
    pub samples: *const f32,
    pub n: i32,
    pub sample_rate: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxGeneratedAudio"]
        [::core::mem::size_of::<SherpaOnnxGeneratedAudio>() - 16usize];
    ["Alignment of SherpaOnnxGeneratedAudio"]
        [::core::mem::align_of::<SherpaOnnxGeneratedAudio>() - 8usize];
    ["Offset of field: SherpaOnnxGeneratedAudio::samples"]
        [::core::mem::offset_of!(SherpaOnnxGeneratedAudio, samples) - 0usize];
    ["Offset of field: SherpaOnnxGeneratedAudio::n"]
        [::core::mem::offset_of!(SherpaOnnxGeneratedAudio, n) - 8usize];
    ["Offset of field: SherpaOnnxGeneratedAudio::sample_rate"]
        [::core::mem::offset_of!(SherpaOnnxGeneratedAudio, sample_rate) - 12usize];
};
impl Default for SherpaOnnxGeneratedAudio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SherpaOnnxGeneratedAudioCallback =
    ::core::option::Option<unsafe extern "C" fn(samples: *const f32, n: i32) -> i32>;
pub type SherpaOnnxGeneratedAudioCallbackWithArg = ::core::option::Option<
    unsafe extern "C" fn(samples: *const f32, n: i32, arg: *mut ::std::os::raw::c_void) -> i32,
>;
pub type SherpaOnnxGeneratedAudioProgressCallback =
    ::core::option::Option<unsafe extern "C" fn(samples: *const f32, n: i32, p: f32) -> i32>;
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineTts {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateOfflineTts(
        config: *const SherpaOnnxOfflineTtsConfig,
    ) -> *mut SherpaOnnxOfflineTts;
}
extern "C" {
    pub fn SherpaOnnxDestroyOfflineTts(tts: *mut SherpaOnnxOfflineTts);
}
extern "C" {
    pub fn SherpaOnnxOfflineTtsSampleRate(tts: *const SherpaOnnxOfflineTts) -> i32;
}
extern "C" {
    pub fn SherpaOnnxOfflineTtsNumSpeakers(tts: *const SherpaOnnxOfflineTts) -> i32;
}
extern "C" {
    pub fn SherpaOnnxOfflineTtsGenerate(
        tts: *const SherpaOnnxOfflineTts,
        text: *const ::std::os::raw::c_char,
        sid: i32,
        speed: f32,
    ) -> *const SherpaOnnxGeneratedAudio;
}
extern "C" {
    pub fn SherpaOnnxOfflineTtsGenerateWithCallback(
        tts: *const SherpaOnnxOfflineTts,
        text: *const ::std::os::raw::c_char,
        sid: i32,
        speed: f32,
        callback: SherpaOnnxGeneratedAudioCallback,
    ) -> *const SherpaOnnxGeneratedAudio;
}
extern "C" {
    pub fn SherpaOnnxOfflineTtsGenerateWithProgressCallback(
        tts: *const SherpaOnnxOfflineTts,
        text: *const ::std::os::raw::c_char,
        sid: i32,
        speed: f32,
        callback: SherpaOnnxGeneratedAudioProgressCallback,
    ) -> *const SherpaOnnxGeneratedAudio;
}
extern "C" {
    pub fn SherpaOnnxOfflineTtsGenerateWithCallbackWithArg(
        tts: *const SherpaOnnxOfflineTts,
        text: *const ::std::os::raw::c_char,
        sid: i32,
        speed: f32,
        callback: SherpaOnnxGeneratedAudioCallbackWithArg,
        arg: *mut ::std::os::raw::c_void,
    ) -> *const SherpaOnnxGeneratedAudio;
}
extern "C" {
    pub fn SherpaOnnxDestroyOfflineTtsGeneratedAudio(p: *const SherpaOnnxGeneratedAudio);
}
extern "C" {
    pub fn SherpaOnnxWriteWave(
        samples: *const f32,
        n: i32,
        sample_rate: i32,
        filename: *const ::std::os::raw::c_char,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxWave {
    pub samples: *const f32,
    pub sample_rate: i32,
    pub num_samples: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxWave"][::core::mem::size_of::<SherpaOnnxWave>() - 16usize];
    ["Alignment of SherpaOnnxWave"][::core::mem::align_of::<SherpaOnnxWave>() - 8usize];
    ["Offset of field: SherpaOnnxWave::samples"]
        [::core::mem::offset_of!(SherpaOnnxWave, samples) - 0usize];
    ["Offset of field: SherpaOnnxWave::sample_rate"]
        [::core::mem::offset_of!(SherpaOnnxWave, sample_rate) - 8usize];
    ["Offset of field: SherpaOnnxWave::num_samples"]
        [::core::mem::offset_of!(SherpaOnnxWave, num_samples) - 12usize];
};
impl Default for SherpaOnnxWave {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SherpaOnnxReadWave(filename: *const ::std::os::raw::c_char) -> *const SherpaOnnxWave;
}
extern "C" {
    pub fn SherpaOnnxFreeWave(wave: *const SherpaOnnxWave);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpokenLanguageIdentificationWhisperConfig {
    pub encoder: *const ::std::os::raw::c_char,
    pub decoder: *const ::std::os::raw::c_char,
    pub tail_paddings: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpokenLanguageIdentificationWhisperConfig"]
        [::core::mem::size_of::<SherpaOnnxSpokenLanguageIdentificationWhisperConfig>() - 24usize];
    ["Alignment of SherpaOnnxSpokenLanguageIdentificationWhisperConfig"]
        [::core::mem::align_of::<SherpaOnnxSpokenLanguageIdentificationWhisperConfig>() - 8usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationWhisperConfig::encoder"][::core::mem::offset_of!(
        SherpaOnnxSpokenLanguageIdentificationWhisperConfig,
        encoder
    ) - 0usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationWhisperConfig::decoder"][::core::mem::offset_of!(
        SherpaOnnxSpokenLanguageIdentificationWhisperConfig,
        decoder
    ) - 8usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationWhisperConfig::tail_paddings"][::core::mem::offset_of!(
        SherpaOnnxSpokenLanguageIdentificationWhisperConfig,
        tail_paddings
    )
        - 16usize];
};
impl Default for SherpaOnnxSpokenLanguageIdentificationWhisperConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpokenLanguageIdentificationConfig {
    pub whisper: SherpaOnnxSpokenLanguageIdentificationWhisperConfig,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpokenLanguageIdentificationConfig"]
        [::core::mem::size_of::<SherpaOnnxSpokenLanguageIdentificationConfig>() - 40usize];
    ["Alignment of SherpaOnnxSpokenLanguageIdentificationConfig"]
        [::core::mem::align_of::<SherpaOnnxSpokenLanguageIdentificationConfig>() - 8usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationConfig::whisper"]
        [::core::mem::offset_of!(SherpaOnnxSpokenLanguageIdentificationConfig, whisper) - 0usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationConfig::num_threads"][::core::mem::offset_of!(
        SherpaOnnxSpokenLanguageIdentificationConfig,
        num_threads
    ) - 24usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxSpokenLanguageIdentificationConfig, debug) - 28usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxSpokenLanguageIdentificationConfig, provider) - 32usize];
};
impl Default for SherpaOnnxSpokenLanguageIdentificationConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpokenLanguageIdentification {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateSpokenLanguageIdentification(
        config: *const SherpaOnnxSpokenLanguageIdentificationConfig,
    ) -> *const SherpaOnnxSpokenLanguageIdentification;
}
extern "C" {
    pub fn SherpaOnnxDestroySpokenLanguageIdentification(
        slid: *const SherpaOnnxSpokenLanguageIdentification,
    );
}
extern "C" {
    pub fn SherpaOnnxSpokenLanguageIdentificationCreateOfflineStream(
        slid: *const SherpaOnnxSpokenLanguageIdentification,
    ) -> *mut SherpaOnnxOfflineStream;
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpokenLanguageIdentificationResult {
    pub lang: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpokenLanguageIdentificationResult"]
        [::core::mem::size_of::<SherpaOnnxSpokenLanguageIdentificationResult>() - 8usize];
    ["Alignment of SherpaOnnxSpokenLanguageIdentificationResult"]
        [::core::mem::align_of::<SherpaOnnxSpokenLanguageIdentificationResult>() - 8usize];
    ["Offset of field: SherpaOnnxSpokenLanguageIdentificationResult::lang"]
        [::core::mem::offset_of!(SherpaOnnxSpokenLanguageIdentificationResult, lang) - 0usize];
};
impl Default for SherpaOnnxSpokenLanguageIdentificationResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SherpaOnnxSpokenLanguageIdentificationCompute(
        slid: *const SherpaOnnxSpokenLanguageIdentification,
        s: *const SherpaOnnxOfflineStream,
    ) -> *const SherpaOnnxSpokenLanguageIdentificationResult;
}
extern "C" {
    pub fn SherpaOnnxDestroySpokenLanguageIdentificationResult(
        r: *const SherpaOnnxSpokenLanguageIdentificationResult,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpeakerEmbeddingExtractorConfig {
    pub model: *const ::std::os::raw::c_char,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpeakerEmbeddingExtractorConfig"]
        [::core::mem::size_of::<SherpaOnnxSpeakerEmbeddingExtractorConfig>() - 24usize];
    ["Alignment of SherpaOnnxSpeakerEmbeddingExtractorConfig"]
        [::core::mem::align_of::<SherpaOnnxSpeakerEmbeddingExtractorConfig>() - 8usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingExtractorConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxSpeakerEmbeddingExtractorConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingExtractorConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxSpeakerEmbeddingExtractorConfig, num_threads) - 8usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingExtractorConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxSpeakerEmbeddingExtractorConfig, debug) - 12usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingExtractorConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxSpeakerEmbeddingExtractorConfig, provider) - 16usize];
};
impl Default for SherpaOnnxSpeakerEmbeddingExtractorConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpeakerEmbeddingExtractor {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateSpeakerEmbeddingExtractor(
        config: *const SherpaOnnxSpeakerEmbeddingExtractorConfig,
    ) -> *const SherpaOnnxSpeakerEmbeddingExtractor;
}
extern "C" {
    pub fn SherpaOnnxDestroySpeakerEmbeddingExtractor(
        p: *const SherpaOnnxSpeakerEmbeddingExtractor,
    );
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingExtractorDim(
        p: *const SherpaOnnxSpeakerEmbeddingExtractor,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingExtractorCreateStream(
        p: *const SherpaOnnxSpeakerEmbeddingExtractor,
    ) -> *const SherpaOnnxOnlineStream;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingExtractorIsReady(
        p: *const SherpaOnnxSpeakerEmbeddingExtractor,
        s: *const SherpaOnnxOnlineStream,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingExtractorComputeEmbedding(
        p: *const SherpaOnnxSpeakerEmbeddingExtractor,
        s: *const SherpaOnnxOnlineStream,
    ) -> *const f32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingExtractorDestroyEmbedding(v: *const f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpeakerEmbeddingManager {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateSpeakerEmbeddingManager(
        dim: i32,
    ) -> *const SherpaOnnxSpeakerEmbeddingManager;
}
extern "C" {
    pub fn SherpaOnnxDestroySpeakerEmbeddingManager(p: *const SherpaOnnxSpeakerEmbeddingManager);
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerAdd(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        name: *const ::std::os::raw::c_char,
        v: *const f32,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerAddList(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        name: *const ::std::os::raw::c_char,
        v: *mut *const f32,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerAddListFlattened(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        name: *const ::std::os::raw::c_char,
        v: *const f32,
        n: i32,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerRemove(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerSearch(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        v: *const f32,
        threshold: f32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerFreeSearch(name: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch {
    pub score: f32,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch"]
        [::core::mem::size_of::<SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch>() - 16usize];
    ["Alignment of SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch"]
        [::core::mem::align_of::<SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch>() - 8usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch::score"]
        [::core::mem::offset_of!(SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch, score) - 0usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch::name"]
        [::core::mem::offset_of!(SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch, name) - 8usize];
};
impl Default for SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult {
    pub matches: *const SherpaOnnxSpeakerEmbeddingManagerSpeakerMatch,
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult"]
        [::core::mem::size_of::<SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult>() - 16usize];
    ["Alignment of SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult"]
        [::core::mem::align_of::<SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult>() - 8usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult::matches"][::core::mem::offset_of!(
        SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult,
        matches
    ) - 0usize];
    ["Offset of field: SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult::count"][::core::mem::offset_of!(
        SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult,
        count
    ) - 8usize];
};
impl Default for SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerGetBestMatches(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        v: *const f32,
        threshold: f32,
        n: i32,
    ) -> *const SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerFreeBestMatches(
        r: *const SherpaOnnxSpeakerEmbeddingManagerBestMatchesResult,
    );
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerVerify(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        name: *const ::std::os::raw::c_char,
        v: *const f32,
        threshold: f32,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerContains(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
        name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerNumSpeakers(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerGetAllSpeakers(
        p: *const SherpaOnnxSpeakerEmbeddingManager,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SherpaOnnxSpeakerEmbeddingManagerFreeAllSpeakers(
        names: *const *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineZipformerAudioTaggingModelConfig {
    pub model: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineZipformerAudioTaggingModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineZipformerAudioTaggingModelConfig>() - 8usize];
    ["Alignment of SherpaOnnxOfflineZipformerAudioTaggingModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineZipformerAudioTaggingModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineZipformerAudioTaggingModelConfig::model"][::core::mem::offset_of!(
        SherpaOnnxOfflineZipformerAudioTaggingModelConfig,
        model
    ) - 0usize];
};
impl Default for SherpaOnnxOfflineZipformerAudioTaggingModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxAudioTaggingModelConfig {
    pub zipformer: SherpaOnnxOfflineZipformerAudioTaggingModelConfig,
    pub ced: *const ::std::os::raw::c_char,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxAudioTaggingModelConfig"]
        [::core::mem::size_of::<SherpaOnnxAudioTaggingModelConfig>() - 32usize];
    ["Alignment of SherpaOnnxAudioTaggingModelConfig"]
        [::core::mem::align_of::<SherpaOnnxAudioTaggingModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxAudioTaggingModelConfig::zipformer"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingModelConfig, zipformer) - 0usize];
    ["Offset of field: SherpaOnnxAudioTaggingModelConfig::ced"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingModelConfig, ced) - 8usize];
    ["Offset of field: SherpaOnnxAudioTaggingModelConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingModelConfig, num_threads) - 16usize];
    ["Offset of field: SherpaOnnxAudioTaggingModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingModelConfig, debug) - 20usize];
    ["Offset of field: SherpaOnnxAudioTaggingModelConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingModelConfig, provider) - 24usize];
};
impl Default for SherpaOnnxAudioTaggingModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxAudioTaggingConfig {
    pub model: SherpaOnnxAudioTaggingModelConfig,
    pub labels: *const ::std::os::raw::c_char,
    pub top_k: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxAudioTaggingConfig"]
        [::core::mem::size_of::<SherpaOnnxAudioTaggingConfig>() - 48usize];
    ["Alignment of SherpaOnnxAudioTaggingConfig"]
        [::core::mem::align_of::<SherpaOnnxAudioTaggingConfig>() - 8usize];
    ["Offset of field: SherpaOnnxAudioTaggingConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingConfig, model) - 0usize];
    ["Offset of field: SherpaOnnxAudioTaggingConfig::labels"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingConfig, labels) - 32usize];
    ["Offset of field: SherpaOnnxAudioTaggingConfig::top_k"]
        [::core::mem::offset_of!(SherpaOnnxAudioTaggingConfig, top_k) - 40usize];
};
impl Default for SherpaOnnxAudioTaggingConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxAudioEvent {
    pub name: *const ::std::os::raw::c_char,
    pub index: i32,
    pub prob: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxAudioEvent"][::core::mem::size_of::<SherpaOnnxAudioEvent>() - 16usize];
    ["Alignment of SherpaOnnxAudioEvent"][::core::mem::align_of::<SherpaOnnxAudioEvent>() - 8usize];
    ["Offset of field: SherpaOnnxAudioEvent::name"]
        [::core::mem::offset_of!(SherpaOnnxAudioEvent, name) - 0usize];
    ["Offset of field: SherpaOnnxAudioEvent::index"]
        [::core::mem::offset_of!(SherpaOnnxAudioEvent, index) - 8usize];
    ["Offset of field: SherpaOnnxAudioEvent::prob"]
        [::core::mem::offset_of!(SherpaOnnxAudioEvent, prob) - 12usize];
};
impl Default for SherpaOnnxAudioEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxAudioTagging {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateAudioTagging(
        config: *const SherpaOnnxAudioTaggingConfig,
    ) -> *const SherpaOnnxAudioTagging;
}
extern "C" {
    pub fn SherpaOnnxDestroyAudioTagging(tagger: *const SherpaOnnxAudioTagging);
}
extern "C" {
    pub fn SherpaOnnxAudioTaggingCreateOfflineStream(
        tagger: *const SherpaOnnxAudioTagging,
    ) -> *const SherpaOnnxOfflineStream;
}
extern "C" {
    pub fn SherpaOnnxAudioTaggingCompute(
        tagger: *const SherpaOnnxAudioTagging,
        s: *const SherpaOnnxOfflineStream,
        top_k: i32,
    ) -> *const *const SherpaOnnxAudioEvent;
}
extern "C" {
    pub fn SherpaOnnxAudioTaggingFreeResults(p: *const *const SherpaOnnxAudioEvent);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflinePunctuationModelConfig {
    pub ct_transformer: *const ::std::os::raw::c_char,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflinePunctuationModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflinePunctuationModelConfig>() - 24usize];
    ["Alignment of SherpaOnnxOfflinePunctuationModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflinePunctuationModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflinePunctuationModelConfig::ct_transformer"]
        [::core::mem::offset_of!(SherpaOnnxOfflinePunctuationModelConfig, ct_transformer) - 0usize];
    ["Offset of field: SherpaOnnxOfflinePunctuationModelConfig::num_threads"]
        [::core::mem::offset_of!(SherpaOnnxOfflinePunctuationModelConfig, num_threads) - 8usize];
    ["Offset of field: SherpaOnnxOfflinePunctuationModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxOfflinePunctuationModelConfig, debug) - 12usize];
    ["Offset of field: SherpaOnnxOfflinePunctuationModelConfig::provider"]
        [::core::mem::offset_of!(SherpaOnnxOfflinePunctuationModelConfig, provider) - 16usize];
};
impl Default for SherpaOnnxOfflinePunctuationModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflinePunctuationConfig {
    pub model: SherpaOnnxOfflinePunctuationModelConfig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflinePunctuationConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflinePunctuationConfig>() - 24usize];
    ["Alignment of SherpaOnnxOfflinePunctuationConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflinePunctuationConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflinePunctuationConfig::model"]
        [::core::mem::offset_of!(SherpaOnnxOfflinePunctuationConfig, model) - 0usize];
};
impl Default for SherpaOnnxOfflinePunctuationConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflinePunctuation {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateOfflinePunctuation(
        config: *const SherpaOnnxOfflinePunctuationConfig,
    ) -> *const SherpaOnnxOfflinePunctuation;
}
extern "C" {
    pub fn SherpaOnnxDestroyOfflinePunctuation(punct: *const SherpaOnnxOfflinePunctuation);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxLinearResampler {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateLinearResampler(
        samp_rate_in_hz: i32,
        samp_rate_out_hz: i32,
        filter_cutoff_hz: f32,
        num_zeros: i32,
    ) -> *mut SherpaOnnxLinearResampler;
}
extern "C" {
    pub fn SherpaOnnxDestroyLinearResampler(p: *mut SherpaOnnxLinearResampler);
}
extern "C" {
    pub fn SherpaOnnxLinearResamplerReset(p: *mut SherpaOnnxLinearResampler);
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxResampleOut {
    pub samples: *const f32,
    pub n: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxResampleOut"][::core::mem::size_of::<SherpaOnnxResampleOut>() - 16usize];
    ["Alignment of SherpaOnnxResampleOut"]
        [::core::mem::align_of::<SherpaOnnxResampleOut>() - 8usize];
    ["Offset of field: SherpaOnnxResampleOut::samples"]
        [::core::mem::offset_of!(SherpaOnnxResampleOut, samples) - 0usize];
    ["Offset of field: SherpaOnnxResampleOut::n"]
        [::core::mem::offset_of!(SherpaOnnxResampleOut, n) - 8usize];
};
impl Default for SherpaOnnxResampleOut {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SherpaOnnxLinearResamplerResample(
        p: *mut SherpaOnnxLinearResampler,
        input: *const f32,
        input_dim: i32,
        flush: i32,
    ) -> *const SherpaOnnxResampleOut;
}
extern "C" {
    pub fn SherpaOnnxLinearResamplerResampleFree(p: *const SherpaOnnxResampleOut);
}
extern "C" {
    pub fn SherpaOnnxLinearResamplerResampleGetInputSampleRate(
        p: *const SherpaOnnxLinearResampler,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxLinearResamplerResampleGetOutputSampleRate(
        p: *const SherpaOnnxLinearResampler,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxFileExists(filename: *const ::std::os::raw::c_char) -> i32;
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig {
    pub model: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig"][::core::mem::size_of::<
        SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig,
    >() - 8usize];
    ["Alignment of SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig"][::core::mem::align_of::<
        SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig,
    >() - 8usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig::model"][::core::mem::offset_of!(
        SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig,
        model
    ) - 0usize];
};
impl Default for SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineSpeakerSegmentationModelConfig {
    pub pyannote: SherpaOnnxOfflineSpeakerSegmentationPyannoteModelConfig,
    pub num_threads: i32,
    pub debug: i32,
    pub provider: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineSpeakerSegmentationModelConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineSpeakerSegmentationModelConfig>() - 24usize];
    ["Alignment of SherpaOnnxOfflineSpeakerSegmentationModelConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineSpeakerSegmentationModelConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerSegmentationModelConfig::pyannote"][::core::mem::offset_of!(
        SherpaOnnxOfflineSpeakerSegmentationModelConfig,
        pyannote
    ) - 0usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerSegmentationModelConfig::num_threads"][::core::mem::offset_of!(
        SherpaOnnxOfflineSpeakerSegmentationModelConfig,
        num_threads
    ) - 8usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerSegmentationModelConfig::debug"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerSegmentationModelConfig, debug) - 12usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerSegmentationModelConfig::provider"][::core::mem::offset_of!(
        SherpaOnnxOfflineSpeakerSegmentationModelConfig,
        provider
    ) - 16usize];
};
impl Default for SherpaOnnxOfflineSpeakerSegmentationModelConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SherpaOnnxFastClusteringConfig {
    pub num_clusters: i32,
    pub threshold: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxFastClusteringConfig"]
        [::core::mem::size_of::<SherpaOnnxFastClusteringConfig>() - 8usize];
    ["Alignment of SherpaOnnxFastClusteringConfig"]
        [::core::mem::align_of::<SherpaOnnxFastClusteringConfig>() - 4usize];
    ["Offset of field: SherpaOnnxFastClusteringConfig::num_clusters"]
        [::core::mem::offset_of!(SherpaOnnxFastClusteringConfig, num_clusters) - 0usize];
    ["Offset of field: SherpaOnnxFastClusteringConfig::threshold"]
        [::core::mem::offset_of!(SherpaOnnxFastClusteringConfig, threshold) - 4usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineSpeakerDiarizationConfig {
    pub segmentation: SherpaOnnxOfflineSpeakerSegmentationModelConfig,
    pub embedding: SherpaOnnxSpeakerEmbeddingExtractorConfig,
    pub clustering: SherpaOnnxFastClusteringConfig,
    pub min_duration_on: f32,
    pub min_duration_off: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineSpeakerDiarizationConfig"]
        [::core::mem::size_of::<SherpaOnnxOfflineSpeakerDiarizationConfig>() - 64usize];
    ["Alignment of SherpaOnnxOfflineSpeakerDiarizationConfig"]
        [::core::mem::align_of::<SherpaOnnxOfflineSpeakerDiarizationConfig>() - 8usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationConfig::segmentation"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerDiarizationConfig, segmentation) - 0usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationConfig::embedding"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerDiarizationConfig, embedding) - 24usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationConfig::clustering"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerDiarizationConfig, clustering) - 48usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationConfig::min_duration_on"][::core::mem::offset_of!(
        SherpaOnnxOfflineSpeakerDiarizationConfig,
        min_duration_on
    ) - 56usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationConfig::min_duration_off"][::core::mem::offset_of!(
        SherpaOnnxOfflineSpeakerDiarizationConfig,
        min_duration_off
    ) - 60usize];
};
impl Default for SherpaOnnxOfflineSpeakerDiarizationConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineSpeakerDiarization {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SherpaOnnxCreateOfflineSpeakerDiarization(
        config: *const SherpaOnnxOfflineSpeakerDiarizationConfig,
    ) -> *const SherpaOnnxOfflineSpeakerDiarization;
}
extern "C" {
    pub fn SherpaOnnxDestroyOfflineSpeakerDiarization(
        sd: *const SherpaOnnxOfflineSpeakerDiarization,
    );
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationGetSampleRate(
        sd: *const SherpaOnnxOfflineSpeakerDiarization,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationSetConfig(
        sd: *const SherpaOnnxOfflineSpeakerDiarization,
        config: *const SherpaOnnxOfflineSpeakerDiarizationConfig,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SherpaOnnxOfflineSpeakerDiarizationResult {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SherpaOnnxOfflineSpeakerDiarizationSegment {
    pub start: f32,
    pub end: f32,
    pub speaker: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SherpaOnnxOfflineSpeakerDiarizationSegment"]
        [::core::mem::size_of::<SherpaOnnxOfflineSpeakerDiarizationSegment>() - 12usize];
    ["Alignment of SherpaOnnxOfflineSpeakerDiarizationSegment"]
        [::core::mem::align_of::<SherpaOnnxOfflineSpeakerDiarizationSegment>() - 4usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationSegment::start"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerDiarizationSegment, start) - 0usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationSegment::end"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerDiarizationSegment, end) - 4usize];
    ["Offset of field: SherpaOnnxOfflineSpeakerDiarizationSegment::speaker"]
        [::core::mem::offset_of!(SherpaOnnxOfflineSpeakerDiarizationSegment, speaker) - 8usize];
};
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationResultGetNumSpeakers(
        r: *const SherpaOnnxOfflineSpeakerDiarizationResult,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationResultGetNumSegments(
        r: *const SherpaOnnxOfflineSpeakerDiarizationResult,
    ) -> i32;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationResultSortByStartTime(
        r: *const SherpaOnnxOfflineSpeakerDiarizationResult,
    ) -> *const SherpaOnnxOfflineSpeakerDiarizationSegment;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationDestroySegment(
        s: *const SherpaOnnxOfflineSpeakerDiarizationSegment,
    );
}
pub type SherpaOnnxOfflineSpeakerDiarizationProgressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        num_processed_chunk: i32,
        num_total_chunks: i32,
        arg: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArg = ::core::option::Option<
    unsafe extern "C" fn(num_processed_chunk: i32, num_total_chunks: i32) -> i32,
>;
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationProcess(
        sd: *const SherpaOnnxOfflineSpeakerDiarization,
        samples: *const f32,
        n: i32,
    ) -> *const SherpaOnnxOfflineSpeakerDiarizationResult;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationProcessWithCallback(
        sd: *const SherpaOnnxOfflineSpeakerDiarization,
        samples: *const f32,
        n: i32,
        callback: SherpaOnnxOfflineSpeakerDiarizationProgressCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> *const SherpaOnnxOfflineSpeakerDiarizationResult;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationProcessWithCallbackNoArg(
        sd: *const SherpaOnnxOfflineSpeakerDiarization,
        samples: *const f32,
        n: i32,
        callback: SherpaOnnxOfflineSpeakerDiarizationProgressCallbackNoArg,
    ) -> *const SherpaOnnxOfflineSpeakerDiarizationResult;
}
extern "C" {
    pub fn SherpaOnnxOfflineSpeakerDiarizationDestroyResult(
        r: *const SherpaOnnxOfflineSpeakerDiarizationResult,
    );
}
